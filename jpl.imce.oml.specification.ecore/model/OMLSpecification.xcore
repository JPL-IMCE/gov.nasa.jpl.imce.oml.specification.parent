@GenModel(copyrightText="
Copyright 2016 California Institute of Technology (\"Caltech\").
U.S. Government sponsorship acknowledged.

Licensed under the Apache License, Version 2.0 (the \"License\");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

     http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an \"AS IS\" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
", featureDelegation="None",
   modelPluginVariables="org.eclipse.xtext.xbase.lib org.eclipse.emf.ecore.xcore.lib org.eclipse.emf.cdo",
   rootExtendsClass="org.eclipse.emf.internal.cdo.CDOObjectImpl",
   rootExtendsInterface="org.eclipse.emf.cdo.CDOObject",
   childCreationExtenders="true", 
   pluginKey="OML", 
   modelName="OML", prefix="OML",
   modelPluginID="jpl.imce.oml.specification.ecore",
   modelDirectory="/jpl.imce.oml.specification.ecore/src-gen", 
   
   editPluginID="jpl.imce.oml.specification.ecore.edit",
   editPluginClass="jpl.imce.oml.specification.ecore.edit.provider.OMLEditPlugin", 
   editDirectory="/jpl.imce.oml.specification.ecore.edit/src-gen", 
   
   editorPluginID="jpl.imce.oml.specification.ecore.editor", 
   editorPluginClass="jpl.imce.oml.specification.eore.editor.presentation.OMLEditorPlugin", 
   editorDirectory="/jpl.imce.oml.specification.ecore.editor/src-gen")
   
package jpl.imce.oml.specification.ecore

/* 
 * If present, the value of the 'kind' key specifies a Scala immutable collection.
 * Recognized values are 'Map' (the key type is specified in the 'key' value) and 'Set'
 */
annotation "http://imce.jpl.nasa.gov/oml/Collection" as Collection

/* 
 * If present, indicates that this feature overrides another feature in a parent.
 * Normally, this information should be accessible from the EMF API; however,
 * it is not obvious how to get it.
 */
annotation "http://imce.jpl.nasa.gov/oml/Override" as Override

/*
 * If present, disables including the feature in the resolver API & resolver Implementation
 * This is used for:
 * - classes that are intended for the EMF API but not the functional resolver API
 * - operations that will generate an EMF API operation but have no sensible equivalent in the functional resolver API
 * - structural features with a corresponding read-only immutable query operation
 *   (the structural feature is not part of the functional API; the immutable query operation is)
 * - inverse container features
 */
annotation "http://imce.jpl.nasa.gov/oml/NotFunctionalAPI" as NotFunctionalAPI

/*
 * If present, disables including the feature in the normalized schema tables API
 */
annotation "http://imce.jpl.nasa.gov/oml/NotSchema" as NotSchema

/*
 * If present, indicates that a Class represents a value in some other table
 */
annotation "http://imce.jpl.nasa.gov/oml/ValueTable" as ValueTable

/*
 * Use @Scala(code="...") when the XCore operation body
 * is an Xbase XMemberFeatureCall because the XCore API
 * assumes that the generated code is for Java so it internally
 * converts feature calls into Java query operation calls.
 */
annotation "http://imce.jpl.nasa.gov/oml/Scala" as Scala

/*
 * Use on structural features to specify whether it participates in ordering criteria for instances of the class.
 */
annotation "http://imce.jpl.nasa.gov/oml/IsOrderingKey" as IsOrderingKey

/*
 * Use on a structural feature to specify that the OMLResolvedFactory needs to include a "copy" constructor
 * to clone an instance of the feature's class replacing the value of the annotated feature. 
 */
annotation "http://imce.jpl.nasa.gov/oml/CopyConstructor" as CopyConstructor

/*
 * If present, indicates that a glossary entry must be generated for the documentation.
 */
annotation "http://imce.jpl.nasa.gov/oml/Glossary" as Glossary

/*
 * An IRI based on RFC 3987
 */
type IRI wraps String
/*
 * A local name of an IRI
 */
type LocalName wraps String
/*
 * A lexical value for a real, a decimal or an integer number
 */
type LexicalValue wraps String
/*
 * A lexical value for a real, a decimal or an integer number
 */
type LexicalNumber wraps String
/*
 * A lexical value for a time instant with and without time zone offsets
 */
type LexicalTime wraps String
/*
 * A regular expression for a string based on rule of xsd:pattern
 */
type Pattern wraps String
/*
 * An RFC-4122 UUID (either Version 4 (random) or Version 5 (SHA-1 hash & namespace) 
 */
type UUID wraps String
/*
 * A language range based on RFC 5646
 */
type Language wraps String

type AbbrevIRI wraps String

type NamespacePrefix wraps String

/*
 * An OML Resource is an abstraction for 
 * everything in a vocabulary that is identifiable
 * locally by name within the vocabulary and 
 * globally by an IRI across multiple vocabularies.
 * For a particular OML Resource, the constraints 
 * between its name and its IRI depend on what kind of OML Resource it is.
 */
@Glossary
abstract class Resource {
	
	@NotSchema
	op IRI[1] iri()
	
	op LocalName[1] name()
}

/*
 * An OML TerminologyThing is an abstraction for everything
 * in a vocabulary that is globally identified by a UUID.
 */
@Glossary
abstract class TerminologyThing {
	
	@IsOrderingKey
	derived UUID[1] uuid get { calculateUUID() }
	
	@NotSchema
	op UUID calculateUUID()
}

/*
 * An OML AnnotationProperty maps to an [OWL2 AnnotationProperty] 
 * and is similarly a non-logical property for associating some information
 * to any OML TerminologyThing in the context of an OML TerminologyBox.
 */
@Glossary
class AnnotationProperty {
	
	@IsOrderingKey
	op UUID[1] uuid() { java.util.UUID.fromString(iri).toString }
	
	IRI[1] iri
	
	id AbbrevIRI[1] abbrevIRI
}

/* 
 * For the OML tabular interchange representation,
 * each AnnotationProperty has a corresponding table of Annotations
 */
@Glossary
@NotSchema
class AnnotationPropertyTable wraps java.util.Map$Entry {
	
	@IsOrderingKey
	refers AnnotationProperty[1] key
	
	@Collection(kind="SortedSet")
	contains AnnotationEntry[] value
}

/*
 * In the OML tabular interchange representation,
 * an OML AnnotationEntry (for a given OML AnnotationProperty) is a triple:
 * - the terminology in which the annotation appears 
 * - the annotated terminology thing (subject)
 * - the value of the AnnotationProperty for that subject in that terminology
 */
@Glossary
@ValueTable
class AnnotationEntry {
	
	@IsOrderingKey
	refers TerminologyBox[1] terminology
	
	@IsOrderingKey 
	refers TerminologyThing[1] subject
	
	@IsOrderingKey
	String[1] value
}

/* 
 * In a given OML TerminologyBox, annotations are indexed by 
 * an OML TerminologyThing subject (key).
 * A subject (key) is associated to a table of OML AnnotationSubjectPropertyValues
 */
@Glossary
@NotFunctionalAPI
class AnnotationSubjectTable wraps java.util.Map$Entry {
	refers TerminologyThing[1] key
	
	contains AnnotationSubjectPropertyValue[] value
}

/*
 * For a given annotated OML TerminologyThing key, 
 * an OML AnnotationSubjectPropertyValue is a pair:
 * - an annotation property 
 * - an annotation value
 */
@Glossary
@NotFunctionalAPI
class AnnotationSubjectPropertyValue {
	refers AnnotationProperty[1] property
	String[1] value
}

/*
 * An OML Annotation maps to an [OWL2 Annotation] and is similarly
 * a non-logical statement in the context of an OML Terminology
 * associating some information as the value of an
 * OML AnnotationProperty for describing a subject (an OML TerminologyThing).
 */
@Glossary
@NotSchema
class Annotation {
	
	@IsOrderingKey
	container TerminologyBox[1] terminology opposite annotations
	
	@IsOrderingKey
	refers AnnotationProperty[1] property
	
	@IsOrderingKey
	refers TerminologyThing[1] subject
	
	@IsOrderingKey
	String[1] value
}

/*
 * An OML TerminologyExtent ...
 */
@Glossary
@NotSchema
class TerminologyExtent {
	
	@CopyConstructor
	@Collection(kind="SortedSet")
	contains AnnotationProperty[] annotationProperties
	
	@CopyConstructor
	@Collection(kind="SortedSet")
	contains TerminologyGraph[] terminologyGraphs opposite graphExtent
	
	@CopyConstructor
	@Collection(kind="SortedSet")
	contains Bundle[] bundles opposite bundleExtent
	
	@CopyConstructor
	@Collection(kind="SortedSet")
	contains DescriptionBox[] descriptions opposite terminologyExtent
	
	@CopyConstructor
	@Collection(kind="SortedSet")
	contains TerminologyInstanceAssertion[] instanceAssertions opposite terminologyExtent
}

/*
 * An OML TerminologyBox is a logical set of OML TerminologyBoxStatements defining the vocabulary 
 * for a domain, possibly by reuse of other vocabularies via OML TerminologyBoxAxioms.
 * The semantics of an OML TerminologyBox domain-specific vocabulary is defined
 * by the mapping to [OWL2-DL] of the other vocabularies it reuses, if any, and
 * that of its OML TerminologyBoxAxioms and OML TerminologyBoxStatements 
 * according to its OML TerminologyGraphKind. 
 */
@Glossary
abstract class TerminologyBox extends TerminologyThing, Resource {
	
	@NotSchema
	op TerminologyExtent[1] extent()
	
	@NotSchema
	op UUID[1] calculateUUID() { 
		com.fasterxml.uuid.Generators.nameBasedGenerator(com.fasterxml.uuid.impl.NameBasedGenerator.NAMESPACE_URL).generate(iri()).toString
	}
	
	@Override
	id IRI[1] iri
	
	@NotFunctionalAPI
	op IRI[1] iri() { getIri() }
	
 	op NamespacePrefix[1] nsPrefix() { getIri().substring(1+getIri().lastIndexOf('/')) }
	
	@NotSchema
	op LocalName[1] name() { nsPrefix }
	
	@NotSchema
	@Collection(kind="SortedSet")
	contains Annotation[] annotations opposite terminology
	
	@NotFunctionalAPI
	op AnnotationSubjectTable[] annotationsBySubject()
	
	@NotSchema
	@Collection(kind="SortedSet")
	op AnnotationPropertyTable[] annotationsByProperty()
	
	@NotSchema
	op TerminologyBox[1] withAnnotations
	(@Collection(kind="SortedSet") AnnotationPropertyTable[] a)
	
	TerminologyGraphKind[1] kind
	
	/*
	 * The TerminologyBoxAxioms asserted in this TerminologyBox
	 */
	@NotSchema
	@Collection(kind="SortedSet")
	contains TerminologyBoxAxiom[] terminologyBoxAxioms opposite terminology
	
	/*
	 * The TerminologyBoxStatements asserted in this TerminologyBox
	 */
	@NotSchema
	@Collection(kind="SortedSet")
	contains TerminologyBoxStatement[] boxStatements opposite graph
	 
	@NotSchema
	op TerminologyBox[1] withBoxStatements
	(@Collection(kind="SortedSet") TerminologyBoxStatement[] s)
	
	/*
	 * The subset of statements that are entities.
     */
    @NotSchema
	@Scala(code="boxStatements.selectByKindOf { case e: Entity => e }")
	@Collection(kind="SortedSet")
	op Entity[] entities()
	
	/*
	 * The subset of statements that are aspects.
     */
    @NotSchema
	@Scala(code="boxStatements.selectByKindOf { case a: Aspect => a }")
	@Collection(kind="SortedSet")
	op Aspect[] aspects()
	
	/*
	 * The subset of statements that are concepts.
     */
    @NotSchema
	@Scala(code="boxStatements.selectByKindOf { case c: Concept => c }")
	@Collection(kind="SortedSet")
	op Concept[] concepts()
	
	/*
	 * The subset of statements that are reified relationships.
     */
    @NotSchema
	@Scala(code="boxStatements.selectByKindOf { case rr: ReifiedRelationship => rr }")
	@Collection(kind="SortedSet")
	op ReifiedRelationship[] reifiedRelationships()
		
	/*
	 * The subset of statements that are unreified relationships.
     */
    @NotSchema
	@Scala(code="boxStatements.selectByKindOf { case ur: UnreifiedRelationship => ur }")
	@Collection(kind="SortedSet")
	op UnreifiedRelationship[] unreifiedRelationships()
	
	/*
	 * The subset of statements that are data relationships.
     */
    @NotSchema
	@Scala(code="boxStatements.selectByKindOf { case dr: DataRelationship => dr }")
	@Collection(kind="SortedSet")
	op DataRelationship[] dataRelationships()
	
	/*
	 * A map for the subset of statements that are 
	 * entity scalar data property terms indexed by their uuid.
     */
    @NotSchema
	@Scala(code="boxStatements.selectByKindOf { case dp: EntityScalarDataProperty => dp }")
	@Collection(kind="SortedSet")
	op EntityScalarDataProperty[] entityScalarDataProperties()
	
	/*
	 * A map for the subset of statements that are 
	 * data range terms indexed by their uuid.
     */
    @NotSchema
	@Scala(code="boxStatements.selectByKindOf { case dr: DataRange => dr }")
	@Collection(kind="SortedSet")
	op DataRange[] dataranges()
	
	/*
	 * A map for the subset of statements that are 
	 * scalar datatype terms indexed by their uuid.
     */
    @NotSchema
	@Scala(code="boxStatements.selectByKindOf { case s: Scalar => s }")
	@Collection(kind="SortedSet")
	op Scalar[] scalars()
	
	/*
	 * A map for the subset of statements that are 
	 * structured datatype terms indexed by their uuid.
     */
    @NotSchema
	@Scala(code="boxStatements.selectByKindOf { case s: Structure => s }")
	@Collection(kind="SortedSet")
	op Structure[] structures()
	
	/*
	 * The subset of axioms about terms.
	 */
    @NotSchema
	@Scala(code="boxStatements.selectByKindOf { case tx: TermAxiom => tx }")
	@Collection(kind="SortedSet")
	op TermAxiom[] termAxioms()
	
	@NotSchema
	@Scala(code="scala.collection.immutable.SortedSet.empty[resolver.api.TerminologyThing] ++ boxStatements + this")
	@Collection(kind="SortedSet")
	op TerminologyThing[] everything()
}

/*
 * A Bundle is a concrete TerminologyBox that is 
 * an acyclic logical aggregate of other TerminologyBoxes (see TerminologyBundleAxiom)
 * and that can assert concept disjunctions (See TerminologyBundleStatement)
 */
@Glossary
class Bundle extends TerminologyBox {
		
	@NotSchema
	op TerminologyExtent[1] extent() { bundleExtent }
		
	@NotSchema
	container TerminologyExtent[1] bundleExtent opposite bundles
	
	@NotSchema
	@Scala(code="copy(annotations = this.annotations ++ resolver.convertToAnnotations(a))")
	@Override
	op Bundle[1] withAnnotations
	(@Collection(kind="SortedSet") AnnotationPropertyTable[] a)
	
	@NotSchema
	@Scala(code="resolver.groupAnnotationsByProperty(annotations)")
	@Collection(kind="SortedSet")
	@Override
	op AnnotationPropertyTable[] annotationsByProperty()	
	
	/*
	 * The TerminologyBundleStatements asserted in this Bundle
	 */
	@NotSchema
	@Collection(kind="SortedSet")
	contains TerminologyBundleStatement[] bundleStatements opposite bundle
	
	/*
	 * The BundledTerminologyAxioms asserted in this Bundle
	 */
	@NotSchema
	@Collection(kind="SortedSet")
	contains TerminologyBundleAxiom[] terminologyBundleAxioms opposite terminologyBundle
			
	@NotSchema
	@Scala(code="copy(bundleStatements = this.bundleStatements ++ s)")
	op Bundle[1] withBundleStatements
	(@Collection(kind="SortedSet") TerminologyBundleStatement[] s)
	
	@NotSchema
	@Scala(code="copy(boxStatements = this.boxStatements ++ s)")
	@Override
	op Bundle[1] withBoxStatements
	(@Collection(kind="SortedSet") TerminologyBoxStatement[] s)

	@NotSchema
	@Scala(code="super.everything() ++ bundleStatements + this")
	@Collection(kind="SortedSet")
	@Override
	op TerminologyThing[] everything()
}

/*
 * OML supports two different interpretations for OML TerminologyBox vocabularies:
 * - An open-world interpretation where the vocabulary formalizes a particular domain 
 *   that will be used for modeling particular systems in that domain.
 * - A closed-world interpretation where the vocabulary formalizes the description of
 *   a particular system modeled using the open-world vocabulary for a particular domain.
 * The difference between these interpretations primarily affects the mapping to an [OWL2-DL Class]
 * of a concrete OML ConceptualEntity as follows:
 * - For OpenWorldDefinitions, the mapped [OWL2-DL Class] has open-world semantics; that is,
 *   it classifies a set of individuals that share the characteristics and capabilities 
 *   encoded in the [OWL2-DL Class].
 * - For ClosedWorldDefinitions, the mapped [OWL2-DL Class] has a closed-world semantics in
 *   the sense that it is intended to classify a singleton individual uniquely identified
 *   via the values of its identifying OML DataRelationshipFromEntity properties.
 */
@Glossary
enum TerminologyGraphKind {
	/*
	 * Each OML Entity in an OpenWorldDefinitions OML TerminologyBox has the semantics of
	 * an [OWL2-DL Class]; that is, it classifies a set of individuals 
	 * that share the characteristics and capabilities encoded in the [OWL2-DL Class].
	 * A well-formed OML SpecializationAxiom establishing a taxonomic relationship between 
	 * two OML Terms can be asserted arbitrarily in any OpenWorldDefinitions OML TerminologyBox 
	 * that directly or indirectly includes the related OML Terms. 
	 * For example, suppose that OML Concepts `A` and `B`
	 * are defined in OpenWorldDefinitions OML TerminologyBox `P` and `Q` respectively. 
	 * Suppose further that OpenWorldDefinitions OML TerminologyBoxes, `U` and `V`, each
	 * extend both `P` and `Q` where `U` asserts that `A` extends `B` while `V` asserts that `B` extends `A.
	 * This is well-formed; furthermore, an OpenWorldDefinitions OML TerminologyBox extending both `U` and `V` 
	 * would force `A` and `B` to become equivalent OML Concepts per the open-world semantics of [OWL2-DL].
	 */
	OpenWorldDefinitions
	/*
	 * Each OML ConceptualEntity in a ClosedWorldDesignation terminology describes a unique thing 
	 * in the real world uniquely identifiable by the collection of its identifying OML DataRelationshipFromEntity properties
	 * (e.g., serial numbers, unique identifiers, ...).
	 * A well-formed ClosedWorldDesignations OML TerminologyBox is restricted to defining singleton OML ConceptualEntities, each as
	 * a specialization of at least one concrete OML ConceptualEntity defined  in an extended OpenWorldDefinitions OML TerminologyBox.
	 * Each OML ConceptualEntity in a ClosedWorldDesignations OML TerminologyBox maps to
	 * an [OWL2-DL Class] with an axiom asserting its equivalence to an exact cardinality restriction of 1 for
	 * each of its identifying OML DataRelationshipFromEntity properties.
	 */
	ClosedWorldDesignations
}

/*
 * A TerminologyGraph is a kind of TerminologyBox with no statements our axioms involving Bundles.
 */
@Glossary
class TerminologyGraph extends TerminologyBox {
	
	@NotSchema
	op TerminologyExtent[1] extent() { graphExtent }
		
	@NotSchema
	container TerminologyExtent[1] graphExtent opposite terminologyGraphs
	
	@NotSchema
	@Scala(code="copy(annotations = this.annotations ++ resolver.convertToAnnotations(a))")
	@Override
	op TerminologyGraph[1] withAnnotations
	(@Collection(kind="SortedSet") AnnotationPropertyTable[] a)
	
	@NotSchema
	@Scala(code="resolver.groupAnnotationsByProperty(annotations)")
	@Collection(kind="SortedSet")
	@Override
	op AnnotationPropertyTable[] annotationsByProperty()	
	
	@NotSchema
	@Scala(code="copy(boxStatements = this.boxStatements ++ s)")
	@Override
	op TerminologyGraph[1] withBoxStatements
	(@Collection(kind="SortedSet") TerminologyBoxStatement[] s)
}

/*
 * An OML TerminologyStatement ...
 */
@Glossary
abstract class TerminologyStatement extends TerminologyThing {}

/*
 * An OML TerminologyBoxStatement ...
 */
@Glossary
abstract class TerminologyBoxStatement extends TerminologyStatement {
	
	container TerminologyBox[1] graph opposite boxStatements
}

/*
 * An OML TerminologyBundleStatement ...
 */
@Glossary
abstract class TerminologyBundleStatement extends TerminologyStatement {
	
	container Bundle[1] bundle opposite bundleStatements
}

/*
 * An OML Term ...
 */
@Glossary
abstract class Term extends TerminologyBoxStatement, Resource {
	
	/*
	 * The UUID of a Term is a Version5 namespace UUID based on the term's IRI.
	 */
	@NotSchema 
	op UUID[1] calculateUUID() { 
		com.fasterxml.uuid.Generators.nameBasedGenerator(com.fasterxml.uuid.impl.NameBasedGenerator.NAMESPACE_URL).generate(iri()).toString
	}
	
	@Scala(code="graph.iri + \"#\" + name")
	@NotSchema
	@Override
	op IRI[1] iri() { graph.iri() + "#" + name() }
	
	@NotSchema
	@Override
	id LocalName[1] name
	
	@NotSchema
	op LocalName[1] name() { getName() }
}

/*
 * An OML UnaryTermKind ...
 */
@Glossary
abstract class UnaryTermKind {}

/*
 * An OML DirectedBinaryRelationshipKind ...
 */
@Glossary
abstract class DirectedBinaryRelationshipKind {
	
	@NotSchema
	op Term[1] relationshipSubject()
	
	@NotSchema
	op Term[1] relationRange()
}

/*
 * An OML Entity ...
 */
@Glossary
abstract class Entity extends Term {}

/*
 * 
 */
@Glossary
abstract class ConceptualEntity {
	boolean[1] isAbstract
}

/*
 * An OML Aspect ...
 */
@Glossary
class Aspect extends Entity, UnaryTermKind {}

/*
 * An OML Concept ...
 */
@Glossary
class Concept extends Entity, ConceptualEntity, UnaryTermKind {}

/*
 * An OML EntityRelationship ...
 */
@Glossary
abstract class EntityRelationship extends Term, DirectedBinaryRelationshipKind {

 	refers Entity[1] source

	@NotSchema
	op Term[1] relationDomain() { source }

 	refers Entity[1] target

	@NotSchema
	op Term[1] relationRange() { target }
	
 	/*
 	 * 0 <= target.size <= 1
	 */
	boolean[1] isFunctional
 	/*
 	 * 0 <= source.size <= 1
	 */ 	 
 	boolean[1] isInverseFunctional
 	/*
 	 * 1 <= target.size
	 */
 	boolean[1] isEssential
 	/*
 	 * 1 <= source.size 	
	 */
 	boolean[1] isInverseEssential
 	/*
 	 * Whether this relationship is symmetric
	 */
 	boolean[1] isSymmetric
 	/*
 	 * Whether this relationship is asymmetric
	 */
 	boolean[1] isAsymmetric
 	/*
 	 * Whether this relationship is reflexive
	 */
 	boolean[1] isReflexive
 	/*
 	 * Whether this relationship is irreflexive
	 */ 	 
 	boolean[1] isIrreflexive
 	/*
 	 * Whether this relationship is transitive
	 */
 	boolean[1] isTransitive
}

/*
 * An OML ReifiedRelationship ...
 */
@Glossary
class ReifiedRelationship extends EntityRelationship, Entity, ConceptualEntity {
	LocalName[1] unreifiedPropertyName
	LocalName[?] unreifiedInversePropertyName
}

/*
 * An OML UnreifiedRelationship ...
 */
@Glossary
class UnreifiedRelationship extends EntityRelationship {}

/*
 * An OML Datatype ...
 */
@Glossary
abstract class Datatype extends Term, UnaryTermKind {}

/*
 * An OWL DataRange corresponds to an OWL2 DataRange with arity=1.
 */
@Glossary
abstract class DataRange extends Datatype {}

/*
 * An OML Scalar corresponds to an OWL2 Declaration of a Datatype with arity=1.
 */
@Glossary
class Scalar extends DataRange {}

/*
 * An OML DataRelationship ...
 */
@Glossary
abstract class DataRelationship extends Term, DirectedBinaryRelationshipKind {
	
	@NotSchema
	op Term[1] source()
	
	@NotSchema
	op Term[1] relationDomain() { source }
	
	@NotSchema
	op Datatype[1] target()
	
	@NotSchema
	op Term[1] relationRange() { target }
}

/*
 * An OML DataRelationshipDomain ...
 */
@Glossary
abstract class DataRelationshipDomain {}

/*
 * An OML DataRelationshipFromEntity defines a binary relationship 
 * from an OML Entity domain to an OML Datatype of some kind.
 * The mapping of an OML DataRelationshipFromEntity to [OWL2-DL]
 * depends on the kind of OML Datatype.
 * The semantics of an OML DataRelationshipFromEntity to [OWL2-DL]
 * depends on whether it is an identity criteria for its OML Entity domain.
 */
@Glossary
abstract class DataRelationshipFromEntity extends DataRelationshipDomain {
	refers Entity[1] domain
	
	/*
	 * Specifies the OntoClean IdentityCriteria semantics of an OML DataRelationshipFromEntity:
	 * - +IC, if true; which means that every OML ConceptualEntity defined in a ClosedWorldDesignations OML Terminology
	 *   has an exact cardinality restriction of 1 for the possible values of the relationship, which is an
	 *   encoding in [OWL2-DL] of
	 * - ~IC, if false
	 */
	@Glossary
	boolean[1] isIdentityCriteria
}

/*
 * An OML DataRelationshipFromStructure ...
 */
@Glossary
abstract class DataRelationshipFromStructure extends DataRelationshipDomain {
	refers Structure[1] domain
}

/*
 * An OML DataRelationshipRange ...
 */
@Glossary
abstract class DataRelationshipRange {}

/*
 * An OML DataRelationshipToScalar ...
 */
@Glossary
abstract class DataRelationshipToScalar extends DataRelationshipRange {
	refers DataRange[1] range
}

/*
 * An OML DataRelationshipToStructure ...
 */
@Glossary
abstract class DataRelationshipToStructure extends DataRelationshipRange {
	refers Structure[1] range
}

/*
 * An OML EntityStructuredDataProperty ...
 */
@Glossary
class EntityStructuredDataProperty extends DataRelationship, DataRelationshipFromEntity, DataRelationshipToStructure {
	
	@NotSchema
	@Override
	op Term[1] source() { domain }
	
	@NotSchema
	@Override
	op Datatype[1] target() { range }
}

/*
 * An OML EntityScalarDataProperty ...
 */
@Glossary
class EntityScalarDataProperty extends DataRelationship, DataRelationshipFromEntity, DataRelationshipToScalar {
	
	@NotSchema
	@Override
	op Term[1] source() { domain }
	
	@NotSchema
	@Override
	op Datatype[1] target() { range }
}

/*
 * An OML StructuredDataProperty ...
 */
@Glossary
class StructuredDataProperty extends DataRelationship, DataRelationshipFromStructure, DataRelationshipToStructure {
	
	@NotSchema
	@Override
	op Term[1] source() { domain }
	
	@NotSchema
	@Override
	op Datatype[1] target() { range }
}

/*
 * An OML ScalarDataProperty ...
 */
@Glossary
class ScalarDataProperty extends DataRelationship, DataRelationshipFromStructure, DataRelationshipToScalar {
	
	@NotSchema
	@Override
	op Term[1] source() { domain }
	
	@NotSchema
	@Override
	op Datatype[1] target() { range }
}

/*
 * An OML Structure would correspond to an OWL2 Declaration of a Datatype with arity > 1.
 * However, since OWL2 Datatypes in the [OWL2-DL] are restricted to have arity=1,
 * the OML mapping to [OWL2-DL] involves a pattern-based usage of an [OWL2-DL Class] to represent an OML Structure.
 * The arity corresponds to the cardinality of the set of ScalarDataProperty & StructuredDataProperty 
 * relationships whose domain is this structure.
 */
@Glossary
class Structure extends Datatype {}

/*
 * An OML Axiom ...
 */
@Glossary
abstract class Axiom extends TerminologyBoxStatement {}

/*
 * An OML TerminologyAxiom is asserted in a TerminologyBox of some kind.
 */
@Glossary
abstract class TerminologyAxiom extends TerminologyThing {
	
	/*
	 * The source TerminologyBox
	 */
	@NotSchema
	op TerminologyBox[1] source()
	
	/*
	 * The target TerminologyBox
	 */
	@NotSchema
	op TerminologyBox[1] target()
}

/*
 * An OML TerminologyBoxAxiom is a TerminologyAxiom that asserts a logical statement about a Term.
 */
@Glossary
abstract class TerminologyBoxAxiom extends TerminologyAxiom {
	
	@CopyConstructor
	container TerminologyBox[1] terminology opposite terminologyBoxAxioms
}

/*
 * An OML TerminologyBundleAxiom is a TerminologyAxiom that asserts a logical statement in the context of a Bundle.
 */
@Glossary
abstract class TerminologyBundleAxiom extends TerminologyAxiom {

	@CopyConstructor
	container Bundle[1] terminologyBundle opposite terminologyBundleAxioms

}

/*
 * An OML ConceptTreeDisjunction represents the root & non-leaf nodes of a concept taxonomy:
 * - Root node is a RootConceptTaxonomyAxiom.
 * - Non-leaf nodes are AnonymousConceptTaxonomyAxioms.
 */
@Glossary
abstract class ConceptTreeDisjunction {}

/*
 * An OML DisjointUnionOfConceptsAxioms represents non-leaf & leaf nodes of a concept taxonomy:
 * - Non-leaf nodes are AnonymousConceptTaxonomyAxioms.
 * - Leaf nodes are SpecificDisjointConceptAxioms.
 */
@Glossary
abstract class DisjointUnionOfConceptsAxiom extends TerminologyBundleStatement {
	
	/*
	 * The parent of this node in a disjoint concept taxonomy tree.
	 */
	refers ConceptTreeDisjunction[1] disjointTaxonomyParent
}

/*
 * An OML SpecificDisjointConceptAxiom specifies a leaf in a taxonomy tree.
 */
@Glossary
class SpecificDisjointConceptAxiom extends DisjointUnionOfConceptsAxiom {
	
	/*
	 * A Concept that is a disjoint leaf in a taxonomy tree.
	 */
	 refers Concept[1] disjointLeaf
}

/*
 * An OML AnonymousConceptTaxonomyAxiom is an anonymous taxonomy tree of DisjointUnionOfEntityAxioms.
 */
@Glossary
class AnonymousConceptTaxonomyAxiom extends DisjointUnionOfConceptsAxiom, ConceptTreeDisjunction {}

/*
 * An OML RootConceptTaxonomyAxiom asserts that, in the context of a Bundle, a particular Entity
 * is the root of a taxonomy of specializations of that Entity.
 */
@Glossary
class RootConceptTaxonomyAxiom extends TerminologyBundleStatement, ConceptTreeDisjunction {
	
	/*
	 * The Concept that is at the root of a taxonomy of disjunctions.
	 */
	refers Concept[1] root
	
}

/*
 * An OML BundledTerminologyAxiom identifies an OML TerminologyBox that an OML Bundle aggregates.
 * An OML BundledTerminologyAxiom allows an OML Bundle to
 * make references (via OML TerminologyStatements) to OML TerminologyThings
 * within the transitive closure of a bundledTerminology.
 */
@Glossary
class BundledTerminologyAxiom extends TerminologyBundleAxiom {

	@CopyConstructor
	refers TerminologyBox[1] bundledTerminology
	
	/*
	 * The bundle is the source
	 */
	@NotSchema
	@Override
	op TerminologyBox[1] source() { terminologyBundle }
	
	/*
	 * The bundledTerminology is the target
	 */
	@NotSchema
	@Override
	op TerminologyBox[1] target() { bundledTerminology }
}

/*
 * An OML ConceptDesignationTerminologyAxiom ...
 */
@Glossary
class ConceptDesignationTerminologyAxiom extends TerminologyBoxAxiom {
	
	@NotSchema
	@Scala(code="terminology match { case g: TerminologyGraph => g }")
	op TerminologyGraph[1] designationTerminologyGraph()
	 
	@NotSchema
	@CopyConstructor
	refers TerminologyBox[1] designatedTerminology
	
	refers Concept[1] designatedConcept
	 
	/*
	 * The designationTerminologyGraph is the source
	 */
	@NotSchema
	@Override
	op TerminologyBox[1] source() { terminology }
	
	/*
	 * The TerminologyBox that asserts the designatedConcept is the target
	 */
	@NotSchema
	@Override
	op TerminologyBox[1] target() { designatedTerminology }
}

/*
 * An OML TerminologyExtensionAxiom allows an extendingTerminology to
 * make references (via TerminologyStatements) to TerminologyThings
 * within the transitive closure of the extendedTerminlogy.
 */
@Glossary
class TerminologyExtensionAxiom extends TerminologyBoxAxiom {

	@NotSchema
	op UUID[1] calculateUUID() { 
		val namespace = "TerminologyExtensionAxiom(source=" + source().uuid + ",target="+target().uuid+")"
		com.fasterxml.uuid.Generators.nameBasedGenerator(com.fasterxml.uuid.impl.NameBasedGenerator.NAMESPACE_URL).generate(namespace).toString
	}
	
	@NotSchema
	op TerminologyBox[1] extendingTerminology() { terminology }
	
	@CopyConstructor
  	refers TerminologyBox[1] extendedTerminology
  	
	/*
	 * The extendingTerminology is the source
	 */
	@NotSchema
	@Override
	op TerminologyBox[1] source() { terminology }
	
	/*
	 * The extendedTerminology is the target
	 */
	@NotSchema
	@Override
	op TerminologyBox[1] target() { extendedTerminology }
  	
}

/*
 * An OML TerminologyNestingAxiom ...
 */
@Glossary
class TerminologyNestingAxiom extends TerminologyBoxAxiom {

  	@CopyConstructor
	refers TerminologyBox[1] nestingTerminology

	@NotSchema
	@Scala(code="terminology match { case g: TerminologyGraph => g }")
	op TerminologyGraph[1] nestedTerminology()

  	refers Concept[1] nestingContext
  	
	/*
	 * The nestedTerminology is the source
	 */
	@NotSchema
	@Override
	op TerminologyBox[1] source() { terminology }
	
	/*
	 * The nestingTerminology is the target
	 */
	@NotSchema
	@Override
	op TerminologyBox[1] target() { nestingTerminology }
  	
}

/*
 * An OML TermAxiom ...
 */
@Glossary
abstract class TermAxiom extends Axiom {}

/*
 * An OML EntityRestrictionAxiom ...
 */
@Glossary
abstract class EntityRestrictionAxiom extends TermAxiom {

	 refers ReifiedRelationship[1] restrictedRelation

	 refers Entity[1] restrictedRange

	 refers Entity[1] restrictedDomain
}

/*
 * An OML EntityExistentialRestrictionAxiom ...
 */
@Glossary
class EntityExistentialRestrictionAxiom extends EntityRestrictionAxiom {}

/*
 * An OML EntityUniversalRestrictionAxiom ...
 */
@Glossary
class EntityUniversalRestrictionAxiom extends EntityRestrictionAxiom {}

/*
 * An OML SpecializationAxiom ...
 */
@Glossary
abstract class SpecializationAxiom extends TermAxiom {
	/*
	 * Get the sub (child) term
	 */
	@NotSchema
	op Term[1] child()
	/*
	 * Get the super (parent) term
	 */
	@NotSchema
	op Term[1] parent()
}

/*
 * An OML AspectSpecializationAxiom ...
 */
@Glossary
class AspectSpecializationAxiom extends SpecializationAxiom {
	
	@NotSchema
	op UUID[1] calculateUUID() { 
		val namespace = "AspectSpecializationAxiom(subEntity=" + subEntity.uuid + ",superAspect="+superAspect.uuid+")"
		com.fasterxml.uuid.Generators.nameBasedGenerator(com.fasterxml.uuid.impl.NameBasedGenerator.NAMESPACE_URL).generate(namespace).toString
	}
	
	/*
	 * The sub (child) entity
	 */
	refers Entity[1] subEntity
	/*
	 * The super (parent) aspect
	 */
	refers Aspect[1] superAspect
	/*
	 * Get the sub (child) entity
	 */
	@NotSchema
	@Override
	op Term[1] child() { subEntity }
	/*
	 * Get the super (parent) entity
	 */
	@NotSchema
	@Override
	op Term[1] parent() { superAspect }
}

/*
 * An OML ConceptSpecializationAxiom ...
 */
@Glossary
class ConceptSpecializationAxiom extends SpecializationAxiom {
	refers Concept[1] subConcept
	refers Concept[1] superConcept
	/*
	 * Get the sub (child) entity
	 */
	@NotSchema
	@Override
	op Term[1] child() { subConcept }
	/*
	 * Get the super (parent) entity
	 */
	@NotSchema
	@Override
	op Term[1] parent() { superConcept }
}

/*
 * An OML ReifiedRelationshipSpecializationAxiom ...
 */
@Glossary
class ReifiedRelationshipSpecializationAxiom extends SpecializationAxiom {
	/*
	 * The sub (child) relationship
	 */
	refers ReifiedRelationship[1] subRelationship
	/*
	 * The super (parent) relationship
	 */
	refers ReifiedRelationship[1] superRelationship
	/*
	 * Get the sub (child) entity
	 */
	@NotSchema
	@Override
	op Term[1] child() { subRelationship }
	/*
	 * Get the super (parent) entity
	 */
	@NotSchema
	@Override
	op Term[1] parent() { superRelationship }
}

/*
 * Semantics: OWL2 Data Property Restrictions
 */
@Glossary
abstract class EntityScalarDataPropertyRestrictionAxiom extends TermAxiom {
	refers Entity[1] restrictedEntity
  	refers EntityScalarDataProperty[1] scalarProperty
}

/*
 * An OML EntityScalarDataPropertyExistentialRestrictionAxiom maps to an 
 * OWL2 DataSomeValuesFrom restriction (the range must be explicitly defined as a Scalar datatype)
 */
@Glossary
class EntityScalarDataPropertyExistentialRestrictionAxiom 
extends EntityScalarDataPropertyRestrictionAxiom {
  	refers DataRange[1] scalarRestriction
}

/*
 * An OML EntityScalarDataPropertyUniversalRestrictionAxiom maps to an
 * OWL2 DataAllValuesFrom (the range must be explicitly defined as a Scalar datatype)
 */
@Glossary
class EntityScalarDataPropertyUniversalRestrictionAxiom 
extends EntityScalarDataPropertyRestrictionAxiom {
  	refers DataRange[1] scalarRestriction
}

/**
 * An OML EntityScalarDataPropertyParticularRestrictionAxiom maps to an OWL2 DataHasValue restriction.
 */
@Glossary
class EntityScalarDataPropertyParticularRestrictionAxiom
extends EntityScalarDataPropertyRestrictionAxiom {
	LexicalValue[1] literalValue
}

/*
 * An OML RestrictedDataRange corresponds to an OWL2 DataRange defined in terms of some kind of restriction of some other OML DataRange.
 * Instead of arbitrary OWL2 FacetRestrictionAxioms as constructors of OWL2 DataRanges,
 * the specializations of RestrictedDataRange correspond to the allowed restrictions in OWL2-DL datatype maps.
 * Node that the vocabulary of XSD fundamental facets is not included in OWL2-DL, consequently, 
 * there is no support in OML for specifying datatype restrictions involving XSD fundamental facets as well.
 * @see https://www.w3.org/TR/owl2-syntax/#Data_Ranges
 * @see https://www.w3.org/TR/owl2-syntax/#Datatype_Maps
 */ 
@Glossary
abstract class RestrictedDataRange extends DataRange {
	/*
	 * The restricted (general) data range of this data range (specific)
	 */
	refers DataRange[1] restrictedRange
}

/*
 * An OML BinaryScalarRestriction is a data range that specifies how one binary scalar adds facet restrictions to another.
 * Applies when the restricted scalar represents binary data (OWL2: 4.5)
 * i.e., when it is one of the following scalars (or their transitively restricted ones):
 * xsd:hexBinary
 * xsd:base64Binary
 * xsd:minLength, xsd:maxLength, and xsd:length
 */
@Glossary
class BinaryScalarRestriction extends RestrictedDataRange {
	/*
	 * The length of the binary data
	 */
	int[?] length
	/*
	 * The minimum length of the binary data
	 */
	int[?] minLength
	/*
	 * The maximum length of the binary data
	 */
	int[?] maxLength
}

/*
 * An OML IRIScalarRestriction is a data range that specifies how one IRI scalar adds facet restrictions to another.
 * Applies when the restricted scalar represents IRIs (OWL2: 4.6)
 * i.e., when it is one of the following scalars (or their transitively restricted ones):
 * xsd:anyURI
 */
@Glossary
class IRIScalarRestriction extends RestrictedDataRange {
	/*
	 * The length of the IRI
	 */
	int[?] length
	/*
	 * The minimum length of the IRI
	 */
	int[?] minLength
	/*
	 * The maximum length of the IRI
	 */
	int[?] maxLength
	/*
	 * The pattern of the IRI (https://www.w3.org/TR/xmlschema-2/#regexs)
	 */
	Pattern[?] pattern
}

/*
 * An OML NumericScalarRestriction is a data range that specifies how one numeric scalar range adds facet restrictions to another.
 * Applies when the restricted scalar represents real, decimal or integer numbers (OWL2: 4.1/4.2)
 * i.e., when it is one of the following scalars (or their transitively restricted ones):
 * owl:real
 * owl:rational
 * xsd:decimal
 * xsd:integer
 * xsd:nonNegativeInteger
 * xsd:nonPositiveInteger
 * xsd:positiveInteger
 * xsd:negativeInteger
 * xsd:long
 * xsd:int
 * xsd:short
 * xsd:byte
 * xsd:unsignedLong
 * xsd:unsignedInt
 * xsd:unsignedShort
 * xsd:unsignedByte
 * xsd:double
 * xsd:float
 */
@Glossary
class NumericScalarRestriction extends RestrictedDataRange {
	/*
	 * The inclusive minimum value in the range
	 */
	LexicalNumber[?] minInclusive
	/*
	 * The inclusive maximum value in the range
	 */
	LexicalNumber[?] maxInclusive
	/*
	 * The exclusive minimum value in the range
	 */
	LexicalNumber[?] minExclusive
	/*
	 * The exclusive maximum value in the range
	 */
	LexicalNumber[?] maxExclusive
}

/*
 * An OML PlainLiteralScalarRestriction is a data range that specifies how one plain literal scalar adds facet restrictions to another.
 * Applies when the restricted scalar represents plain literals (OWL2: 4.3)
 * i.e., when it is one of the following scalars (or their transitively restricted ones):
 * rdf:PlainLiteral
 */
@Glossary
class PlainLiteralScalarRestriction extends RestrictedDataRange {
	/*
	 * The length of the plain literal
	 */
	int[?] length
	/*
	 * The minimum length of the plain literal
	 */
	int[?] minLength
	/*
	 * The maximum length of the plain literal
	 */
	int[?] maxLength
	/*
	 * The pattern of the plain literal (https://www.w3.org/TR/xmlschema-2/#regexs)
	 */
	Pattern[?] pattern
	/*
	 * The language of the plain literal (http://www.rfc-editor.org/rfc/bcp/bcp47.txt)
	 */
	Language[?] language
}

/*
 * An OML StringScalarRestriction is a data range that specifies how one string scalar adds facet restrictions to another.
 * Applies when the restricted scalar represents strings (OWL2: 4.3)
 * i.e., when it is one of the following scalars (or their transitively restricted ones):
 * xsd:string
 * xsd:normalizedString
 * xsd:token
 * xsd:language
 * xsd:Name
 * xsd:NCName
 * xsd:NMTOKEN
 * xsd:length, xsd:minLength, xsd:maxLength, xsd:pattern
 */
@Glossary
class StringScalarRestriction extends RestrictedDataRange {
	/*
	 * The length of the string
	 */
	int[?] length
	/*
	 * The minimum length of the string
	 */
	int[?] minLength
	/*
	 * The maximum length of the string
	 */
	int[?] maxLength
	/*
	 * The pattern of the string (https://www.w3.org/TR/xmlschema-2/#regexs)
	 */
	Pattern[?] pattern
}

/*
 * An OML TimeScalarRestriction is a data range that specifies how one time scalar adds facet restrictions to another.
 * Applies when the restricted scalar represents time instants (OWL2: 4.7)
 * i.e., when it is one of the following scalars (or their transitively restricted ones):
 * xsd:dateTime
 * xsd:dateTimeStamp
 */
@Glossary
class TimeScalarRestriction extends RestrictedDataRange {
	/*
	 * The inclusive minimum value in the range
	 */
	LexicalTime[?] minInclusive
	/*
	 * The inclusive maximum value in the range
	 */
	LexicalTime[?] maxInclusive
	/*
	 * The exclusive minimum value in the range
	 */
	LexicalTime[?] minExclusive
	/*
	 * The exclusive maximum value in the range
	 */
	LexicalTime[?] maxExclusive
}

/*
 * An OML SynonymScalarRestriction is a data range that is defined as a synonym for another (i.e. the restrictedRange).
 */
@Glossary
class SynonymScalarRestriction extends RestrictedDataRange {}

/*
 * An OML ScalarOneOfRestriction is a data range that specifies how a scalar is a restricted set of literal values of another.
 * Semantics: OWL2 DataOneOf
 */
@Glossary
class ScalarOneOfRestriction extends RestrictedDataRange {}

/*
 * An OML ScalarOneOfLiteralAxiom specifies a literal in a ScalarOneOfRestriction data range.
 */
@Glossary
class ScalarOneOfLiteralAxiom extends Axiom {
	refers ScalarOneOfRestriction[1] axiom
	/*
	 * The value of the literal from the restrictedScalar datatype
	 */
	LexicalValue[1] value
}

/*
 * An OML DescriptionBox ...
 */
@Glossary
class DescriptionBox extends TerminologyThing, Resource {
	
	@NotSchema
	container TerminologyExtent[1] terminologyExtent opposite descriptions
	
	@NotSchema
	@Collection(kind="SortedSet")
	contains DescriptionBoxExtendsClosedWorldDefinitions[] closedWorldDefinitions opposite descriptionBox
	
	@NotSchema
	@Collection(kind="SortedSet")
	contains DescriptionBoxRefinement[] descriptionBoxRefinements opposite refiningDescriptionBox
	
	@NotSchema
	@Collection(kind="SortedSet")
	refers ConceptInstance[] conceptInstances
	
	@NotSchema
	@Collection(kind="SortedSet")
	refers ReifiedRelationshipInstance[] reifiedRelationshipInstances
	
	@NotSchema
	@Collection(kind="SortedSet")
	refers ReifiedRelationshipInstanceDomain[] reifiedRelationshipInstanceDomains
	
	@NotSchema
	@Collection(kind="SortedSet")
	refers ReifiedRelationshipInstanceRange[] reifiedRelationshipInstanceRanges
	
	@NotSchema
	@Collection(kind="SortedSet")
	refers UnreifiedRelationshipInstanceTuple[] unreifiedRelationshipInstanceTuples
	
	@NotSchema
	@Collection(kind="SortedSet")
	refers DataStructureTuple[] dataStructureTuples
	
	@NotSchema
	@Collection(kind="SortedSet")
	refers ScalarDataPropertyValue[] scalarDataPropertyValues
	
	@NotSchema
	@Collection(kind="SortedSet")
	refers StructuredDataPropertyValue[] structuredDataPropertyValues
	
	@NotSchema
	@Scala(code="copy(conceptInstances = this.conceptInstances ++ s)")
	op DescriptionBox[1] withConceptInstances
	(@Collection(kind="SortedSet") ConceptInstance[] s)
	
	@NotSchema
	@Scala(code="copy(reifiedRelationshipInstances = this.reifiedRelationshipInstances ++ s)")
	op DescriptionBox[1] withReifiedRelationshipInstances
	(@Collection(kind="SortedSet") ReifiedRelationshipInstance[] s)
	
	@NotSchema
	@Scala(code="copy(reifiedRelationshipInstanceDomains = this.reifiedRelationshipInstanceDomains ++ s)")
	op DescriptionBox[1] withReifiedRelationshipInstanceDomains
	(@Collection(kind="SortedSet") ReifiedRelationshipInstanceDomain[] s)
	
	@NotSchema
	@Scala(code="copy(reifiedRelationshipInstanceRanges = this.reifiedRelationshipInstanceRanges ++ s)")
	op DescriptionBox[1] withReifiedRelationshipInstanceRanges
	(@Collection(kind="SortedSet") ReifiedRelationshipInstanceRange[] s)
	
	@NotSchema
	@Scala(code="copy(unreifiedRelationshipInstanceTuples = this.unreifiedRelationshipInstanceTuples ++ s)")
	op DescriptionBox[1] withUnreifiedRelationshipInstanceTuples
	(@Collection(kind="SortedSet") UnreifiedRelationshipInstanceTuple[] s)
	
	@NotSchema
	@Scala(code="copy(dataStructureTuples = this.dataStructureTuples ++ s)")
	op DescriptionBox[1] withDataStructureTuples
	(@Collection(kind="SortedSet") DataStructureTuple[] s)
	
	@NotSchema
	@Scala(code="copy(scalarDataPropertyValues = this.scalarDataPropertyValues ++ s)")
	op DescriptionBox[1] withScalarDataPropertyValues
	(@Collection(kind="SortedSet") ScalarDataPropertyValue[] s)
	
	@NotSchema
	@Scala(code="copy(structuredDataPropertyValues = this.structuredDataPropertyValues ++ s)")
	op DescriptionBox[1] withStructuredDataPropertyValues
	(@Collection(kind="SortedSet") StructuredDataPropertyValue[] s)
}

/*
 * An OML DescriptionBoxExtendsClosedWorldDefinitions ...
 */
@Glossary
class DescriptionBoxExtendsClosedWorldDefinitions extends TerminologyThing {
	container DescriptionBox[1] descriptionBox opposite closedWorldDefinitions
	refers TerminologyBox[1] closedWorldDefinitions
}

/*
 * An OML DescriptionBoxRefinement ...
 */
@Glossary
class DescriptionBoxRefinement extends TerminologyThing {
	container DescriptionBox[1] refiningDescriptionBox opposite descriptionBoxRefinements
	refers DescriptionBox[1] refinedDescriptionBox
}

/*
 * An OML TerminologyInstanceAssertion ...
 */
@Glossary
abstract class TerminologyInstanceAssertion extends TerminologyThing {
	@NotSchema
	container TerminologyExtent[1] terminologyExtent opposite instanceAssertions
}

/*
 * An OML SingletonInstance ...
 */
@Glossary
abstract class SingletonInstance extends TerminologyInstanceAssertion, Resource {}

/*
 * An OML ...
 */
@Glossary
class ScalarDataPropertyValue extends TerminologyInstanceAssertion {
	refers SingletonInstance[1] singletonInstance
	refers DataRelationshipToScalar[1] scalarDataProperty
	String[1] scalarPropertyValue
}

/*
 * An OML StructuredDataPropertyValue ...
 */
@Glossary
class StructuredDataPropertyValue extends TerminologyInstanceAssertion {
	refers SingletonInstance[1] singletonInstance
	refers DataRelationshipToStructure[1] structuredDataProperty
	refers DataStructureTuple[1] structuredPropertyTuple
}

/*
 * An OML DataStructureTuple ...
 */
@Glossary
class DataStructureTuple extends SingletonInstance {
	refers Structure[1] dataStructureType
}

/*
 * An OML ConceptualEntitySingletonInstance ...
 */
@Glossary
abstract class ConceptualEntitySingletonInstance extends SingletonInstance {
	@NotSchema
	op ConceptualEntity[1] conceptualEntitySingletonClassifier()
	
	@NotSchema
	@Collection(kind="SortedSet")
	refers ScalarDataPropertyValue[] identifyingScalarValues
	
	@NotSchema
	@Collection(kind="SortedSet")
	refers DataStructureTuple[] identifyingStructuredTuples
}

/*
 * An OML ConceptInstance ...
 */
@Glossary
class ConceptInstance extends ConceptualEntitySingletonInstance {
	refers Concept[1] singletonConceptClassifier
	
	@NotSchema
	@Override
	op ConceptualEntity[1] conceptualEntitySingletonClassifier() { singletonConceptClassifier }
}

/*
 * An OML ReifiedRelationshipInstance ...
 */
@Glossary
class ReifiedRelationshipInstance extends ConceptualEntitySingletonInstance {
	refers ReifiedRelationship[1] singletonReifiedRelationshipClassifier
	
	@NotSchema
	@Override
	op ConceptualEntity[1] conceptualEntitySingletonClassifier() { singletonReifiedRelationshipClassifier }
}

/*
 * An OML ReifiedRelationshipInstanceDomain ...
 */
@Glossary
class ReifiedRelationshipInstanceDomain extends TerminologyInstanceAssertion {
	refers ReifiedRelationshipInstance[1] reifiedRelationshipInstance
	refers ConceptualEntitySingletonInstance[1] domain
}

/*
 * An OML ReifiedRelationshipInstanceRange ...
 */
@Glossary
class ReifiedRelationshipInstanceRange extends TerminologyInstanceAssertion {
	refers ReifiedRelationshipInstance[1] reifiedRelationshipInstance
	refers ConceptualEntitySingletonInstance[1] range
}

/*
 * An OML UnreifiedRelationshipInstanceTuple ...
 */
@Glossary
class UnreifiedRelationshipInstanceTuple extends TerminologyInstanceAssertion {
	refers UnreifiedRelationship[1] unreifiedRelationship
	refers ConceptualEntitySingletonInstance[1] domain
	refers ConceptualEntitySingletonInstance[1] range
}